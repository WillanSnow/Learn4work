# 竞赛类算法

> 竞赛类算法的一大特点是数学性，此类算法题多于数论、图论、奥数(规律)等数学知识息息相关。  
> 想要提高对应能力，必须在日常训练中**多积累、多观察、多总结**


## 多次数组操作

> 对数组进行分区间的多次操作，而我们**无法遍历、枚举**时，需要对操作进行**抽象记录**，或者**规律总结**。
>
> 两类方法有共通点也有不同特点
> - 规律类
>   - 常常不需要给出中间过程，直接给出结果
> - 记录类
>   - 结果与数据有强依赖性，需要操作完成时，才能得出具体结果
>   - 注意操作的**特殊性**，类型相似的操作不一定

### Swap and Reverse[~](https://codeforces.com/contest/1864/problem/B)

- 描述：给定字符串$str$，数字$k$，执行如下操作无限次，返回可得到的最小字典序：
  - **Swap**：交换$str[i]、str[i+2]$
  - **reverse**：翻转$[i,i+k-1]$段字符串
- 题解思路：
  - 由**Swap**可知，奇数、偶数位上的字符可以自由排序；
  - 由**reverse**：
    - 当$k$为奇数时，翻转后字符下标的奇偶性不变，返回奇偶下标分别字典序排序结果；
    - 当$k$为偶数时，翻转后的字符下标奇偶性改变，字符可以任意换位，<font color = red>可证</font>，返回字典序排序即可。

> 此题对于多次数组的多次操作具有**规律性**，总结每次操作后的结果，找到规律后返回题目结果即可。

### Matrix Wave[~](https://codeforces.com/contest/1864/problem/D)
- 描述：给定$n*n$的0、1矩阵，当翻转$(i,j)$位置的元素时，满足$x-i\leq |y-j|$的$(x,y)$位置也会翻转，求得到全0矩阵需要执行翻转操作的最小次数。
- 题解思路：
  - 翻转时，只会影响下行的矩阵，按行向下遍历可确定最小翻转次数；
  - 奇数次翻转改变数值；偶数次数值不变；
  - 由题意，翻转时，由翻转位置向下延伸出两条直线将矩阵划分，为了快速记录翻转操作影响，用**独立的前缀和数组**记录操作边界，节省遍历分区的时间。
- 题解代码：[code](HarbourSpaceScholarshipContest/D.cpp)

### 题目名[~](https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/)
- 描述：给定禁入数组$fobidden$，前移距离$a$，后移距离$b$，终点$x$；初始位于$0$处，每次移动时，可以向前、后移动$a、b$距离
  - 限制：1.禁入$fobidden$位置；2.不可连续后退；3.可以超过$x$位置，但不能移到负数位置
  - 返回：到达$x$需要的最小移动次数
- 题解思路：
  - **$bfs$**：找最短路，广搜是最直接的方法。  
    需要注意以下几点：
    - 搜索边界：<font color=red>证明</font>，搜索上界为：
      $$ \begin{cases}
        a==b& x\\
        a>b & x+b\\
        a<b&  max(max(forbidden)+a,x)+b
      \end{cases} $$
    - 操作不同性：前后移动到达有差异，需要用不同的标记记录；

## 2的幂

### Divisor Chain[~](https://mirror.codeforces.com/contest/1864/problem/C)
- 描述：对于给定的整数$x$，选择$x$的一个除数$d$，$x-=d$，重复多次，使结果得到$1$，要求选择的除数使用次数不超过两次。返回操作次数(理论上应$\leq1000$)，操作链($x->...->1$)。
- 题解思路：
  - 分两步
    1. 令$2^L$有不大于$x$的最大$L$，先将$x$减到$2^L$；(证明：将$x$转化为二进制，则**二进制最低有效位一定是该数的因数**，不断去除最低有效位，直到剩余唯一有效位，此时$x=2^L$)
    2. 对于$2^L$，显然存在如下链条：$2^L->2^{L-1}->2^{L-2}->...->1$；
    3. 上述操作，每次都选择2的幂作为除数，使用次数不超过两次，符合题意。
