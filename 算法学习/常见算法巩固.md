# 算法

## dfs

常用于**枚举、图论遍历**；  
一般时间复杂度为$O(n)$，其中的$n$，在图论中为节点数，在枚举中为可能的枚举数。

涉及的数据结构/算法：
> 栈：`stack<template>、empty、push、pop、top`
> 递归

## bfs

常用于**图论遍历**；  
时间复杂度为$O(n)$。

涉及数据结构：
> 队列：`queue<template>、empty、push、pop、front`

### 拓扑排序

拓扑排序是基于**入度**的bfs，时间复杂度为$O(n)$。
> 新产生的0入度结点必定是上一次搜索点的相邻点，找新0入度结点的时间复杂度不会很高。

## 双指针

常用于**查找、搜索**

### 滑动窗口

## 二分

二分的不同写法：
```c++
lf = 0, rt = n-1;
while (lf < rt) {
    mid = (lf + rt) /2;
    if (mid < target) lf = mid+1;
    /* 取中间值时向左偏移，处理边界时，左端点向右走 */
    else rt = mid;
}
return lf;

while (lf < rt) {
    mid = (lf + rt + 1)/2;
    if (mid <= target) lf = mid;
    else rt = mid-1;
    /* 取中间值时向右偏移，处理边界时，右端点向左走 */
}
```
为了始终满足$target \isin [lf,\ rt]$，要保持带等号的`if`处理不取$\pm 1$；为了避免无限循环，中心偏向点和$\pm 1$点应该相同。

## 排序

## 贪心

涉及的数据结构。
> 优先队列：`priority_queue<template>、empty、push、pop、top`

# 数据结构

## 线段树[~](https://oi-wiki.org/ds/seg/)

> 线段树用于管理区间信息，可以在$O(\log n)$时间内实现**单点修改、区间修改、区间查询(求和、最大值、最小值)……**
> 
> 维护长度为$n$的数组区间时，线段树空间需要为$2^{\lceil log n\rceil + 1}$，实际使用时，由于$2^{\lceil log n\rceil + 1} < 4n$(可证)，我们往往使用$4n$长度的数组存放线段树。

设线段树用于维护数据长度为$n$的$nums$数组的区间信息。

**实现方法**：
线段树是一颗**二叉树**，树结点记录区间$[l,r]$**区间和**，每个区间长度不为1的结点有左右两个子结点。

**建树**：
- 建树时考虑**递归**构造，令根节点表示区间$[1,n]$的区间和；对于每个区间长度不为1的节点$i$，递归构建左、右子节点，节点编号和区间由公式求出，节点值等于左右子节点的节点值和；
- 公式：
  - 子节点编号：$i_l = i*2,\ i_r = i*2+1$；
  - 子节点区间：当前节点的区间为$[l,r]$，则左、右子节点区间为$\big[l, \lfloor (l+r)/2 \rfloor\big], \big[\lfloor (l+r+1)/2 \rfloor, r\big]$；
  - 节点值：$val_i = val_{lf}+ val_{rt}$。

**线段树操作**
- 区间查询
  - 设查询区间为$[s,e]$，
- 维护(懒惰标记)
- 动态开点
- 优化