# 项目简介

基于32位 Linux 0.11 内核，从0设计面向i386平台的原型操作系统。

# 实验过程

## lab 1：编译内核，启动OS

下载代码、合适版本的gcc编译器，用make工具编译内核，编译时注意添加参数（-g生成内核符号表用于调试，-m 32用于32位系统）。

编译完成后，使用quem启动操作系统，此时已可以完成一些简单命令行操作。

gdb远程调试，观察重要地址的内容（0x7DFE、0x7DFF）。

qemu挂载磁盘。

## lab 2：汇编基础

汇编基础实验，了解汇编语言的语法、逻辑控制等。

**MBR**：如何编写并装载？

中断调用：在汇编语言中，使用中断指令调用系统中断（调用前设置好参数寄存器的值，调用后从结果寄存器获取返回值）

## lab 3：保护模式（实模式）

两种磁盘读取中断：
- LBA：虚拟扇区编号，对访问过程进行抽象，使用更加简便，且可访问的范围更广；
- CHS：根据硬盘工作原理实现读写。

保护模式跳转：拷贝端口数据->位运算修改标志位->拷贝新值到端口，间接修改端口的特定位。

## lab 4：中断

C/C++/汇编混合编程：
1. 编译原理：C语言不支持重载，编译后的汇编文件中，函数名不变；C++使用函数签名实现重载，编译后可能修改函数名，应将特定的函数声明为C语言；
2. Rust函数：global设置函数为全局函数，extern声明其它文件（C/C++编译后的文件）中的函数；
3. C/C++调用汇编函数：使用extern关键字声明；
4. C语言可变参数：printf函数实现

修改中断处理函数：阅读源码，替换处理函数为自己的函数。

**中断向量表**

## lab 5：线程调度

- PCB组成与代码实现：基本数据结构为链表，为实现线程控制，需要成员“pid、线程名、栈指针、线程状态”，为实现特定的调度算法，需要成员“时间片计时、优先级、队列标识”
- 线程切换：使用ret指令实现跳转，通过修改栈内容（ret参数）实现不同线程的切换。
- 线程调度算法：FCFS、RR、优先级抢占式

## lab 6：同步与互斥

内核态如何实现**自旋锁**、**信号量**
- 利用汇编语言提供的原子指令lock bts（取数并比较），进而实现自旋锁。
- 基于自旋锁，设置缓冲区和计数变量，实现信号量。

## lab 7：内存管理

数组模拟内存分配与释放

页表的实现：引入虚拟内存后，程序中使用的所有地址均为虚拟地址，因此需要这是一些特别的字段帮助我们找到页表。

## lab 8：系统调用和进程管理

1. 如何添加、修改系统调用
2. fork函数：即是系统调用，也是进程管理函数，需要对其进行多层封装，以满足它的多个属性：fork->设置为系统调用->封装为系统调用->封装为进程管理函数。
3. wait、exit：执行exit函数后，进程停止运行，返回值存入PCB，保留PCB，根据PCB信息完成内存回收、父进程回收返回值等任务，再调用进程调度函数，将该PCB销毁。

## lab 9：请求调页机制

1. 实现磁盘读写：基于磁盘读写中断，实现以页为单位的内存交互；
2. 封装：调页即是内存管理函数，也是系统调用。