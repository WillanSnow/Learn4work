# 前言

进程是运行的程序，是os实现各种功能的基础；线程是进程的附庸。

# 进程

## 进程状态

进程的五大状态：创建、运行、等待、就绪、终止。
- 创建：只能进入就绪态；
- 就绪：调度后进入运行态；
- 运行：发生中断，进入就绪态；I/O或调度，进入等待态；执行完成，进入终止态；
- 等待：只能进入就绪态；
- 终止：终止无法进入其它状态，进程销毁。

## 地址空间

不同进程之间的地址空间相互独立，而同一进程的不同线程共享地址空间。

## 进程调度

**进程控制(PCB)**：  
每个PCB对应一个进程，它包含进程的运行信息：进程状态、进程号、CPU寄存器、CPU调度信息、内存管理信息、记录信息、I/O状态信息等。

os根据PCB信息进行进程调度，决定当前CPU执行哪个进程，哪些进程等待执行。

上下文切换：将进程的执行信息保存在PCB中，换上新的进程，加载新进程PCB中的内容。

## 进程运行

os进程需要关注它的三个阶段：1. 进程创建；2. 进程执行；3. 进程终止。

进程只能通过父进程创建，进程创建时，需要获取软硬件资源，通常有两种方式获取：1. 直接向系统申请分配资源；2. 由父进程分配父进程资源的子集；相对而言，后者更加安全，可以避免申请过多的系统资源。

对于子进程初始化时，也有两个选择：1. 复制父进程的地址空间、数据等；2. 加载一个新程序。

子进程终止后，会进入**僵尸**状态，该进程被标识为终止，申请的系统资源被释放，但其进程条目不会被销毁，直到父进程调用`wait()`函数；
若父进程未调用`wait()`函数就退出，那么子进程变为**孤儿**进程，其进程号从**进程树**中脱离，无法被销毁。

## 进程间通信

出于安全性、可靠性的角度，进程间应当是**完全独立**的，但单一进程往往难以实现复杂功能，进程间相互沟通，协作才是更加合理的选择。

两种进程通信模型：
1. 共享内存：常用于交换较小的消息，缺点是需要较多的系统调用，内核时间长；
2. 消息传递：通信更加快速，除共享区建立外，其它过程不需要内核参与。

# 线程

目前大多数os都支持进程执行多线程。

用户线程&内核线程